Introduction 
Pascal 
- is a simple programming language (i.e., concise, efficient, and easy to read). 
Delphi 
- is an object oriented extension of Pascal (e.g., C to C++)
- adds support for such object oriented paradigms as classes, interfaces, inheritance. 

In the project 1
- We build our own version of Delphi by extending a Pascal grammar (provided)

Specific Requirements 
Antlr4 grammar
- Write a grammar for the part of the language specified below with,
that allow the language to be recognized by an interpreter (written by me),
and an echo function to be performed.
- Note: I do not have to start from scratch. Just build upon the previously linked grammar for Pascal. 

Part of the language to implement 
Implement the following:
- Classes and Objects 
- Constructors and Destructors 
- Ecapsulation 

To demonstrate the above you must: 
- Generate the parser and lexer from the grammar using Antlr4
- Write a Java interpreter to walk through and interpret the AST generated by my parser 
(link for the Java Antlr runtime above)
- Write functionality to input and ouput to the terminal integer numbers using my new language features
- Write test cases to illustrate my newly added functionality 

Bonus (20%)
Implement the following (test cases must also use the Java/ Antlr4 runtime and use intake and print functionality)
- Inheritance 
- Interfaces 

Test Cases 
I have to write test cases covering all the functionality I implement.
The advice is that I write several files, each covering part of the functionality (unit tests).

What to turn in
- grammar delphi.g4
- Java interpreter 
- all the test examples: test1.pas, test2.pas, etc. 
- README file explaining what works and guidance on how to run my code.
- Bundle all the files in a .zip archive so TAs have an easier time running the code. 
- Indicate in the README the steps to run the code 

More notes:
- ANTLR Actions are not required in the grammar.
- Interpreter is simply a Java program that walks through and directly evaluates the AST.
- The functionality required in test files is very simple: just echo an integer from input back to output


---------------------------------------------------------------------------------------------------------


Learning
Lexer (splitting a sentence into words or Tokenization)
- breaks down raw input text into tokens 
- recognizes basic lexical units (e.g., keywords, identifiers, numbers, symbols)
- works based on lexer rules (usually written in uppercase in ANTLR)
- Purpose: Covert raw text into tokens
- Lexer Rules: UPPERCASE
- Output: Stream of tokens
- Example:
NUMBER: [0-9]+ ;
PLUS: '+' ;
MINUS: '-' ;
- If given: "42 + 10", the lexer produces: NUMBER(42), PLUS(+), NUMBER(10)

Parser (Checking if the sentence follows proper grammar and structuring it)
- organizes tokens into a meaningful structure (AST or parse tree)
- applies grammar rules to determine the structure of valid sentences 
- works based on parser rules (usually written in lowercase in ANTLR)
- Parser: Organize tokens into a tree
- Parser Rules: lowercase
- Output: Parse tree or AST
- Example:
expr: NUMBER (PLUS NUMBER)* ;
- For "42 + 10", the parser structures it as:
expr
|- NUMBER(42)
|- PLUS(+)
|- NUMBER(10)

Parse tree (Concrete Syntax tree)
- full representation of the input based on the grammar rules
- includes all tokens and non-terminals
- preserves the exact structure of the input 
- often deep and verbose (containing many redundant nodes)

Abstract Syntax Tree (AST)
- a simplified version of the parse tree
- removes unnecessary nodes (like literals, parentheses, intermediate non-terminals)
- focuses on semantics (meaning), rather than syntax details 
- more compact, making it useful for interpretation or compilation 